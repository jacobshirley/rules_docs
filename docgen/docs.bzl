"""Bazel rules and utilities for generating, organizing, and serving documentation."""

load("@bazel_lib//lib:copy_to_directory.bzl", "copy_to_directory_bin_action")
load("@bazel_lib//lib:paths.bzl", "to_repository_relative_path")
load("@bazel_lib//lib:utils.bzl", "file_exists")
load("@bazel_skylib//rules:build_test.bzl", "build_test")

UNIQUE_FOLDER_NAME = "_bazel_docs"

# Doc nav rules implementation

DocsProviderInfo = provider(
    doc = "Provider to specify docs information, such as files and navigation title",
    fields = {
        "title": "The title of the navigation element",
        "entrypoint": "The entrypoint file for the documentation",
        "files": "The files that are part of the documentation",
        "nav": "The sub navigation elements",
    },
)

DocsLinkInfo = provider(
    doc = "Provider to specify a link to docs (external URL or internal path)",
    fields = {
        "title": "The title of the navigation element",
        "url": "The URL of the navigation element",
        "entrypoint": "The entrypoint file for the documentation",
        "files": "The files that are part of the documentation",
    },
)

def _docs_impl(ctx):
    _GENERATED_FOLDER = ctx.label.name + "__generated"

    coreutils_bin = ctx.toolchains["@bazel_lib//lib:coreutils_toolchain_type"].coreutils_info.bin

    outs = []
    files = [] + ctx.files.data + ctx.files.srcs
    transitive = []

    header = []
    for key, value in ctx.attr.readme_header_links.items():
        if (DocsLinkInfo in key):
            header.append("[**{key}**]({path})".format(
                key = value,
                path = key[DocsLinkInfo].url if key[DocsLinkInfo].url else key[DocsLinkInfo].entrypoint if key[DocsLinkInfo].entrypoint else key.label.name,
            ))

            for f in key[DocsLinkInfo].files:
                files.append(f)
        else:
            header.append("[**{key}**]({path})".format(
                key = value,
                path = key.label.name,
            ))

    prefix = ""
    entrypoint_file_path = None
    if (ctx.attr.entrypoint):
        prefix = ctx.attr.entrypoint.label.workspace_name
        prefix = prefix + "/" if prefix != "" else ""

        entrypoint_file_path = prefix + to_repository_relative_path(ctx.file.entrypoint)

    autogenerated_line = " | ".join(header)
    autogenerated_readme_content = "\n".join([
        autogenerated_line,
    ] + ([ctx.attr.readme_content] if ctx.attr.readme_content != "" else []))

    if (autogenerated_readme_content != ""):
        if (ctx.attr.entrypoint):
            entry = ctx.actions.declare_file(_GENERATED_FOLDER + "/" + ctx.file.entrypoint.basename)

            ctx.actions.run_shell(
                inputs = [ctx.file.entrypoint],
                outputs = [entry],
                tools = [coreutils_bin],
                mnemonic = "WriteEntryReadme",
                command = "echo \"{content}\" | {coreutils} cat - \"{input}\" > \"{output}\"".format(
                    content = "{}".format(autogenerated_readme_content),
                    coreutils = coreutils_bin.path,
                    input = ctx.file.entrypoint.short_path,
                    output = entry.path,
                ),
            )

            files.append(entry)
        elif (autogenerated_readme_content != ""):
            entry = ctx.actions.declare_file(_GENERATED_FOLDER + "/README.md")
            entrypoint_file_path = to_repository_relative_path(entry).replace(_GENERATED_FOLDER + "/", "")

            ctx.actions.write(
                output = entry,
                content = autogenerated_readme_content + "\n#" + ctx.attr.title,
                is_executable = False,
            )

            files.append(entry)
    elif (ctx.file.entrypoint):
        entry = ctx.file.entrypoint
        files.append(ctx.file.entrypoint)

    if (len(files) > 0):
        copy_to_directory_bin = ctx.toolchains["@bazel_lib//lib:copy_to_directory_toolchain_type"].copy_to_directory_info.bin
        out_folder = ctx.actions.declare_directory(ctx.attr.out + prefix)

        replace_prefixes = {}
        replace_prefixes[_GENERATED_FOLDER] = ""

        copy_to_directory_bin_action(
            ctx = ctx,
            copy_to_directory_bin = copy_to_directory_bin,
            name = "_" + ctx.label.name,
            files = files,
            dst = out_folder,
            replace_prefixes = replace_prefixes,
            include_external_repositories = ["*"],
            allow_overwrites = True,
        )

        outs.append(out_folder)

    resolved_nav = []

    for key, value in ctx.attr.nav.items():
        nav_element = {}

        if (DocsProviderInfo in key):
            title = value if value and value != "" else key[DocsProviderInfo].title
            entrypoint = key[DocsProviderInfo].entrypoint
            subnav = key[DocsProviderInfo].nav

            if (len(subnav) > 0):
                nav_element[title] = ([entrypoint] if entrypoint else []) + subnav
            elif (entrypoint):
                nav_element[title] = entrypoint
            else:
                continue
        elif (DocsLinkInfo in key):
            nav_element[value] = key[DocsLinkInfo].url if key[DocsLinkInfo].url != "" else key[DocsLinkInfo].entrypoint if key[DocsLinkInfo].entrypoint != "" else key.label.name
        else:
            nav_element[value] = key.files.to_list()[0].short_path

        resolved_nav.append(nav_element)
        transitive = transitive + [depset(key.files.to_list())]

    return [
        DefaultInfo(
            files = depset(outs, transitive = transitive),
        ),
        DocsProviderInfo(
            title = ctx.attr.title,
            files = files,
            entrypoint = entrypoint_file_path if entrypoint_file_path else None,
            nav = resolved_nav,
        ),
        DocsLinkInfo(
            title = ctx.attr.title,
            files = files,
            entrypoint = entrypoint_file_path if entrypoint_file_path else None,
        ),
    ]

_docs = rule(
    implementation = _docs_impl,
    attrs = {
        "title": attr.string(
            doc = "The title of the navigation element",
        ),
        "entrypoint": attr.label(
            doc = "The entrypoint file for the documentation",
            allow_single_file = True,
        ),
        "srcs": attr.label_list(
            doc = "The files that are part of the documentation",
            allow_files = True,
        ),
        "out": attr.string(
            doc = "The output directory for the documentation",
        ),
        "data": attr.label_list(
            doc = "The data files that are part of the documentation",
        ),
        "deps": attr.label_list(
            doc = "The dependencies of the documentation",
            providers = [DocsProviderInfo],
        ),
        "nav": attr.label_keyed_string_dict(
            doc = "Sub navigation elements",
            allow_files = True,
            providers = [DocsProviderInfo],
        ),
        "readme_content": attr.string(
            doc = "The content of the README.md file",
            default = "",
        ),
        "readme_header_links": attr.label_keyed_string_dict(
            doc = "The links to add to the README.md file",
            allow_files = True,
        ),
        "last_updated_json": attr.label(
            doc = "JSON file with a key->value mapping of file paths to last updated timestamps",
            allow_single_file = True,
        ),
    },
    toolchains = [
        "@bazel_lib//lib:copy_to_directory_toolchain_type",
        "@bazel_lib//lib:coreutils_toolchain_type",
    ],
)

def _docs_add_last_updated_impl(ctx):
    out_folder = ctx.actions.declare_directory(ctx.label.name)

    coreutils_bin = ctx.toolchains["@bazel_lib//lib:coreutils_toolchain_type"].coreutils_info.bin

    # Create a shell action to find all markdown files and write their paths to stdout

    date_format = ctx.attr.last_updated_date_format
    if not date_format:
        date_format = "+%B %d, %Y at %I:%M %p"

    update_history_url = ctx.attr.update_history_url

    ctx.actions.run_shell(
        inputs = ctx.files.docs + [ctx.file.last_updated_json],
        outputs = [out_folder],
        tools = [coreutils_bin],
        mnemonic = "DocsAddLastUpdated",
        command = """

        function update_file {{
            f="$1"

            if [ ! -f "$f" ]; then
                return
            fi

            if [[ "$f" != *".md" ]]; then
                mkdir -p "{folder}/$(dirname "$f")"
                cp "$f" "{folder}/$f"
                chmod 644 "{folder}/$f"
                return
            fi

            mkdir -p "{folder}/$(dirname "$f")"

            # Use cp -L to dereference symlinks and copy actual file content
            cp "$f" "{folder}/$f"
            chmod 644 "{folder}/$f"

            rel_path=$(echo "$f" | sed 's|^.*/_bazel_docs/||')
            last_update_raw=$(jq -r --arg file "$rel_path" '.[$file] // "Unknown"' "{json_file}")

            has_update="false"
            # Format the date if it's not "Unknown"
            if [ "$last_update_raw" != "Unknown" ]; then
                has_update="true"
                # Convert ISO 8601 to readable format
                last_update=$(date -d "$last_update_raw" "{date_format}" 2>/dev/null || echo "$last_update_raw")
            else
                last_update=$(date "{date_format}")
            fi

            # Add last updated information to the footer
            footer_line="---\n"

            # If update history URL is provided, add it to the footer
            update_history_url="{update_history_url}"
            if [ -n "$update_history_url" ] && [ "$has_update" = "true" ]; then
                footer_line+="Last updated: [$last_update]({update_history_url}/$rel_path)\n"
            else
                footer_line+="Last updated: $last_update\n"
            fi

            echo "\n\n$footer_line" >> "{folder}/$f"
        }}

        for file in "$@"; do
            if [ -d "$file" ]; then
                find -L "$file" -type f -print0 | while IFS= read -r -d '' f; do
                    update_file "$f"
                done
            elif [ -f "$file" ]; then
                update_file "$file"
            fi
        done
        """.format(
            folder = out_folder.path,
            out_dir = out_folder.path,
            json_file = ctx.file.last_updated_json.path,
            date_format = date_format,
            update_history_url = update_history_url if update_history_url else "",
        ),
        arguments = [f.path for f in ctx.files.docs],
    )

    files = depset([out_folder])

    return [
        DefaultInfo(
            files = files,
        ),
        DocsProviderInfo(
            title = ctx.attr.docs[DocsProviderInfo].title,
            files = files,
            entrypoint = ctx.attr.docs[DocsProviderInfo].entrypoint,
            nav = ctx.attr.docs[DocsProviderInfo].nav if DocsProviderInfo in ctx.attr.docs else [],
        ),
    ]

docs_add_last_updated = rule(
    implementation = _docs_add_last_updated_impl,
    attrs = {
        "last_updated_json": attr.label(
            doc = "JSON file with a key->value mapping of file paths to last updated timestamps",
            allow_single_file = True,
            mandatory = True,
        ),
        "docs": attr.label(
            doc = "The docs to add last updated information to",
            mandatory = True,
            providers = [DocsProviderInfo],
        ),
        "last_updated_date_format": attr.string(
            doc = "The date format to use for last updated timestamps",
            default = "+%B %d, %Y at %I:%M %p",
        ),
        "update_history_url": attr.string(
            doc = "The URL to the update history",
        ),
    },
    toolchains = [
        "@bazel_lib//lib:coreutils_toolchain_type",
        "@bazel_lib//lib:copy_to_directory_toolchain_type",
    ],
)

def _docs_link_impl(ctx):
    return [
        DefaultInfo(
            files = depset(ctx.files.data),
        ),
        DocsLinkInfo(
            title = ctx.attr.title,
            url = ctx.attr.url,
            entrypoint = ctx.attr.entrypoint if ctx.attr.entrypoint != "" else None,
            files = ctx.files.data,
        ),
    ]

docs_link = rule(
    implementation = _docs_link_impl,
    attrs = {
        "title": attr.string(
            doc = "The title of the navigation element",
        ),
        "url": attr.string(
            doc = "The URL of the navigation element",
        ),
        "entrypoint": attr.string(
            doc = "The entrypoint file for the documentation",
            default = "",
        ),
        "data": attr.label_list(
            doc = "The data files that are part of the documentation",
        ),
    },
    toolchains = [
        "@bazel_lib//lib:copy_to_directory_toolchain_type",
    ],
)

def _mkdocs_config_impl(ctx):
    docs = ctx.attr.docs[DocsProviderInfo]

    base = ctx.file.mkdocs_base
    out = ctx.actions.declare_file(ctx.label.name + ".mkdocs.yml")

    root_nav_folder = ctx.attr.root_nav_folder
    if (root_nav_folder and (not root_nav_folder.endswith("/"))):
        root_nav_folder = root_nav_folder + "/"

    nav_json = json.encode(docs.nav)
    nav = nav_json.replace(root_nav_folder, "") if root_nav_folder else nav_json

    # Write the mkdocs.yml file
    ctx.actions.run_shell(
        inputs = [base],
        outputs = [out],
        progress_message = "Generating mkdocs.yml from %s" % base.short_path,
        command = "echo 'nav: {nav}' | cat - {input} > {output}".format(
            nav = nav,
            input = base.path,
            output = out.path,
        ),
    )

    return [
        DefaultInfo(
            files = depset([out]),
        ),
    ]

mkdocs_config = rule(
    implementation = _mkdocs_config_impl,
    attrs = {
        "title": attr.string(
            doc = "The title of the site",
        ),
        "docs": attr.label(
            doc = "The docs to include in the site",
            providers = [DocsProviderInfo],
        ),
        "mkdocs_base": attr.label(
            doc = "The base mkdocs.yml file",
            allow_single_file = [".yaml", ".yml"],
            mandatory = True,
        ),
        "root_nav_folder": attr.string(
            doc = "The root nav folder",
            default = "",
        ),
    },
)

def _collect_inputs(ctx, root = ""):
    docs_folder = ctx.actions.declare_directory(ctx.label.name + "/" + ctx.attr.docs_dir)

    copy_to_directory_bin = ctx.toolchains["@bazel_lib//lib:copy_to_directory_toolchain_type"].copy_to_directory_info.bin

    replace_prefixes = {
        "**/{}".format(UNIQUE_FOLDER_NAME): "",
    }

    if (root != ""):
        replace_prefixes["**/{}".format(root)] = ""

    # Copy docs
    copy_to_directory_bin_action(
        ctx = ctx,
        copy_to_directory_bin = copy_to_directory_bin,
        name = "_" + ctx.label.name + "_docs",
        files = ctx.files.docs + ctx.files.data,
        dst = docs_folder,
        replace_prefixes = replace_prefixes,
        include_external_repositories = ["*"],
        allow_overwrites = True,
    )

    config = ctx.actions.declare_file(ctx.label.name + "/" + ctx.file.config.basename)

    ctx.actions.symlink(
        output = config,
        target_file = ctx.file.config,
    )

    return [
        docs_folder,
        config,
    ]

def _mkdocs_build_impl(ctx):
    mkdocs_bin = ctx.executable._mkdocs_executable

    docs_folder, config = _collect_inputs(ctx, root = ctx.attr.root_nav_folder)

    inputs = [docs_folder, config]

    out = ctx.actions.declare_directory(ctx.label.name + "/" + ctx.attr.site_dir)

    ctx.actions.run_shell(
        inputs = inputs,
        outputs = [out],
        tools = [mkdocs_bin],
        progress_message = "[mkdocs] Generating site",
        command = "{mkdocs} build $@".format(
            mkdocs = mkdocs_bin.path,
        ),
        arguments = [
            "-f",
            config.path,
            "--site-dir",
            out.basename,
        ],
        use_default_shell_env = ctx.attr.use_default_shell_env,
    )

    return [
        DefaultInfo(
            files = depset([out]),
        ),
    ]

mkdocs_build = rule(
    implementation = _mkdocs_build_impl,
    attrs = {
        "docs": attr.label_list(
            doc = "The docs to include in the site",
            allow_files = True,
        ),
        "data": attr.label_list(
            doc = "The data files to include in the site",
            allow_files = True,
        ),
        "config": attr.label(
            doc = "The mkdocs.yml file",
            allow_single_file = [".yaml", ".yml"],
            mandatory = True,
        ),
        "docs_dir": attr.string(
            doc = "The directory containing the docs",
            default = "docs",
        ),
        "site_dir": attr.string(
            doc = "The output directory for the site",
            default = "site",
        ),
        "root_nav_folder": attr.string(
            doc = "The root nav folder",
            default = "",
        ),
        "use_default_shell_env": attr.bool(
            doc = "Use the default shell environment",
            default = False,
        ),
        "_mkdocs_executable": attr.label(
            doc = "The mkdocs executable",
            executable = True,
            cfg = "exec",
            default = Label("//:mkdocs"),
        ),
    },
    toolchains = [
        "@bazel_lib//lib:copy_to_directory_toolchain_type",
    ],
)

def _mkdocs_serve_impl(ctx):
    mkdocs_bin = ctx.executable._mkdocs_executable

    transitive_runfiles = []
    transitive_runfiles.append(ctx.attr._mkdocs_executable[DefaultInfo].default_runfiles)

    docs_folder, config = _collect_inputs(ctx, root = ctx.attr.root_nav_folder)
    serve_sh = ctx.actions.declare_file(ctx.label.name + ".sh")

    inputs = [docs_folder, config]

    # Write the mkdocs.yml file
    ctx.actions.write(
        output = serve_sh,
        content = "\n".join([
            "#!/bin/bash",
            "set -e",
            "./{mkdocs} serve -f {config}".format(mkdocs = mkdocs_bin.short_path, config = config.short_path),
        ]),
        is_executable = True,
    )

    runfiles = ctx.runfiles(files = ctx.files._mkdocs_executable + inputs + ctx.attr._mkdocs_executable[DefaultInfo].files.to_list())
    runfiles = runfiles.merge_all(transitive_runfiles)

    return [
        DefaultInfo(
            executable = serve_sh,
            runfiles = runfiles.merge_all(transitive_runfiles),
        ),
    ]

mkdocs_serve = rule(
    implementation = _mkdocs_serve_impl,
    attrs = {
        "docs": attr.label_list(
            doc = "The docs to include in the site",
            allow_files = True,
        ),
        "git_folder": attr.label(
            doc = "The git files to use to get last updated information",
            allow_single_file = True,
        ),
        "data": attr.label_list(
            doc = "The data files to include in the site",
            allow_files = True,
        ),
        "config": attr.label(
            doc = "The mkdocs.yml file",
            allow_single_file = [".yaml", ".yml"],
            mandatory = True,
        ),
        "docs_dir": attr.string(
            doc = "The directory containing the docs",
            default = "docs",
        ),
        "root_nav_folder": attr.string(
            doc = "The root nav folder",
            default = "",
        ),
        "_mkdocs_executable": attr.label(
            doc = "The mkdocs executable",
            executable = True,
            cfg = "exec",
            default = Label("//:mkdocs"),
        ),
    },
    toolchains = [
        "@bazel_lib//lib:copy_to_directory_toolchain_type",
        "@bazel_lib//lib:coreutils_toolchain_type",
        "@bazel_lib//lib:copy_directory_toolchain_type",
    ],
    executable = True,
)

def docs(
        name = "docs",
        entry = "README.md",
        srcs = [
            "README.md",
        ],
        data = [],
        deps = [],
        tags = [],
        title = None,
        nav = {},
        out = None,
        readme_content = "",
        readme_header_links = {}):
    out_folder = (out or name) + "/" + UNIQUE_FOLDER_NAME + "/" + native.package_name()

    _docs(
        name = name,
        srcs = srcs + data,
        deps = deps,
        title = title,
        entrypoint = entry if file_exists(entry) or entry.find(":") != -1 else None,
        nav = nav,
        out = out_folder,
        visibility = ["//visibility:public"],
        tags = ["docs"] + tags,
        readme_content = readme_content,
        readme_header_links = readme_header_links,
    )

    build_test(
        name = name + ".test",
        targets = [
            ":" + name,
        ],
    )

def docs_index(
        name = "docs",
        title = None,
        entry = None,
        nav = {},
        tags = []):
    _docs(
        name = name,
        srcs = [],
        title = title,
        entrypoint = entry,
        nav = nav,
        visibility = ["//visibility:public"],
        tags = ["docs"] + tags,
    )

    build_test(
        name = name + ".test",
        targets = [
            ":" + name,
        ],
    )
