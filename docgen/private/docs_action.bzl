"""Internal documentation processing actions."""

load("@bazel_lib//lib:copy_to_directory.bzl", "copy_to_directory_bin_action")
load("@bazel_lib//lib:paths.bzl", "to_repository_relative_path")
load(":providers.bzl", "DocsLinkInfo", "DocsProviderInfo")

def docs_action_impl(ctx):
    """Implementation function for docs_action rule.

    Processes documentation files and generates output with proper linking and file dependencies.

    Args:
        ctx: The rule context.

    Returns:
        A list of providers including DefaultInfo and DocsProviderInfo.
    """
    _GENERATED_FOLDER = ctx.label.name + "__generated"

    coreutils_bin = ctx.toolchains["@bazel_lib//lib:coreutils_toolchain_type"].coreutils_info.bin

    outs = []
    files = [] + ctx.files.data + ctx.files.srcs
    transitive = []

    header = []
    for key, value in ctx.attr.readme_header_links.items():
        if (DocsLinkInfo in key):
            header.append("[**{title}**]({link})".format(
                title = value if value and value != "" else key[DocsLinkInfo].title,
                link = key[DocsLinkInfo].url if key[DocsLinkInfo].url else key[DocsLinkInfo].entrypoint if key[DocsLinkInfo].entrypoint else key.label.name,
            ))

            for f in key[DocsLinkInfo].files:
                files.append(f)
        else:
            header.append("[**{title}**]({link})".format(
                title = value if value and value != "" else key.label.name,
                link = key.label.name,
            ))

    prefix = ""
    entrypoint_file_path = None
    if (ctx.attr.entrypoint):
        prefix = ctx.attr.entrypoint.label.workspace_name if ctx.attr.rewrite_path == "" else ctx.attr.rewrite_path
        prefix = prefix + "/" if prefix != "" else ""

        entrypoint_file_path = prefix + to_repository_relative_path(ctx.file.entrypoint)
    elif (ctx.attr.rewrite_path != ""):
        prefix = ctx.attr.rewrite_path + "/"

    autogenerated_line = " | ".join(header)
    autogenerated_readme_content = "\n".join([
        autogenerated_line,
    ] + ([ctx.attr.readme_content] if ctx.attr.readme_content != "" else []))

    if (autogenerated_readme_content != ""):
        if (ctx.attr.entrypoint):
            entry = ctx.actions.declare_file(_GENERATED_FOLDER + "/" + ctx.file.entrypoint.basename)

            ctx.actions.run_shell(
                inputs = [ctx.file.entrypoint],
                outputs = [entry],
                tools = [coreutils_bin],
                mnemonic = "WriteEntryReadme",
                command = "echo \"{content}\" | {coreutils} cat - \"{input}\" > \"{output}\"".format(
                    content = "{}".format(autogenerated_readme_content),
                    coreutils = coreutils_bin.path,
                    input = ctx.file.entrypoint.short_path,
                    output = entry.path,
                ),
            )

            files.append(entry)
            entrypoint_file_path = to_repository_relative_path(entry).replace(_GENERATED_FOLDER + "/", "")
        elif (autogenerated_readme_content != ""):
            entry = ctx.actions.declare_file(_GENERATED_FOLDER + "/" + ctx.attr.readme_filename)
            entrypoint_file_path = to_repository_relative_path(entry).replace(_GENERATED_FOLDER + "/", "")

            ctx.actions.write(
                output = entry,
                content = autogenerated_readme_content + "\n#" + ctx.attr.title,
                is_executable = False,
            )

            files.append(entry)
    elif (ctx.file.entrypoint):
        entry = ctx.file.entrypoint
        files.append(ctx.file.entrypoint)

    if (len(files) > 0):
        copy_to_directory_bin = ctx.toolchains["@bazel_lib//lib:copy_to_directory_toolchain_type"].copy_to_directory_info.bin
        out_folder = ctx.actions.declare_directory(ctx.attr.out + prefix)

        replace_prefixes = {}
        replace_prefixes[_GENERATED_FOLDER] = ""

        copy_to_directory_bin_action(
            ctx = ctx,
            copy_to_directory_bin = copy_to_directory_bin,
            name = "_" + ctx.label.name,
            files = files,
            dst = out_folder,
            replace_prefixes = replace_prefixes,
            include_external_repositories = ["*"],
            allow_overwrites = True,
        )

        outs.append(out_folder)

    resolved_nav = []

    for key, value in ctx.attr.nav.items():
        nav_element = {}

        if (DocsProviderInfo in key):
            title = value if value and value != "" else key[DocsProviderInfo].title
            entrypoint = key[DocsProviderInfo].entrypoint
            subnav = key[DocsProviderInfo].nav

            if (len(subnav) > 0):
                nav_element[title] = ([entrypoint] if entrypoint else []) + subnav
            elif (entrypoint):
                nav_element[title] = entrypoint
            else:
                continue
        elif (DocsLinkInfo in key):
            title = value if value and value != "" else key[DocsLinkInfo].title
            nav_element[title] = key[DocsLinkInfo].url if key[DocsLinkInfo].url != "" else key[DocsLinkInfo].entrypoint if key[DocsLinkInfo].entrypoint != "" else key.label.name
        else:
            nav_element[value] = key.files.to_list()[0].short_path

        resolved_nav.append(nav_element)
        transitive = transitive + [depset(key.files.to_list())]

    return [
        DefaultInfo(
            files = depset(outs, transitive = transitive),
        ),
        DocsProviderInfo(
            title = ctx.attr.title,
            files = files,
            entrypoint = entrypoint_file_path if entrypoint_file_path else None,
            nav = resolved_nav,
        ),
        DocsLinkInfo(
            title = ctx.attr.title,
            files = files,
            entrypoint = entrypoint_file_path if entrypoint_file_path else None,
        ),
    ]

docs_action = rule(
    implementation = docs_action_impl,
    attrs = {
        "title": attr.string(
            doc = "The title of the navigation element",
        ),
        "entrypoint": attr.label(
            doc = "The entrypoint file for the documentation",
            allow_single_file = True,
        ),
        "srcs": attr.label_list(
            doc = "The files that are part of the documentation",
            allow_files = True,
        ),
        "out": attr.string(
            doc = "The output directory for the documentation",
        ),
        "data": attr.label_list(
            doc = "The data files that are part of the documentation",
        ),
        "deps": attr.label_list(
            doc = "The dependencies of the documentation",
            providers = [DocsProviderInfo],
        ),
        "nav": attr.label_keyed_string_dict(
            doc = "Sub navigation elements",
            allow_files = True,
            providers = [DocsLinkInfo],
        ),
        "rewrite_path": attr.string(
            doc = "The path prefix to rewrite documentation files to",
            default = "",
        ),
        "readme_filename": attr.string(
            doc = "The filename of the README.md file",
            default = "README.md",
        ),
        "readme_content": attr.string(
            doc = "The content of the README.md file",
            default = "",
        ),
        "readme_header_links": attr.label_keyed_string_dict(
            doc = "The links to add to the README.md file",
            allow_files = True,
        ),
    },
    toolchains = [
        "@bazel_lib//lib:copy_to_directory_toolchain_type",
        "@bazel_lib//lib:coreutils_toolchain_type",
    ],
)
